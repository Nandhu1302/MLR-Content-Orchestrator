// ============================================
// Taxonomy Service (JavaScript)
// ============================================

// Assumed import (The original code imports supabase client, though it's unused in the current mock implementation)
import { supabase } from '@/integrations/supabase/client';

/**
 * @typedef {Object} TaxonomyTerm
 * @property {string} id
 * @property {string} category
 * @property {string} [subcategory]
 * @property {string} term
 * @property {string} [description]
 * @property {string} [parent_id]
 * @property {number} taxonomy_level
 * @property {boolean} is_active
 * @property {any} metadata
 * @property {TaxonomyTerm[]} [children]
 */

/**
 * @typedef {Object} TaxonomyMapping
 * @property {string} id
 * @property {string} content_id
 * @property {string} content_type
 * @property {string} taxonomy_id
 * @property {number} confidence_score
 * @property {boolean} is_auto_generated
 * @property {TaxonomyTerm} [taxonomy_term]
 */

/**
 * @typedef {Object} BrandTaxonomyRule
 * @property {string} id
 * @property {string} brand_id
 * @property {string} taxonomy_id
 * @property {boolean} is_required
 * @property {boolean} is_restricted
 * @property {any} custom_rules
 */

class TaxonomyService {
    /**
     * Get taxonomy hierarchy for a specific category
     * Note: Using mock data until database types are updated
     * @param {string} category
     * @returns {Promise<TaxonomyTerm[]>}
     */
    async getTaxonomyByCategory(category) {
        try {
            // Use mock data for now to avoid type errors
            console.log('Getting taxonomy for category:', category);
            return this.getMockTaxonomyData(category);
        } catch (error) {
            console.error('Error getting taxonomy by category:', error);
            return this.getMockTaxonomyData(category);
        }
    }

    /**
     * Get all taxonomy categories
     * @returns {Promise<string[]>}
     */
    async getAllCategories() {
        try {
            return [
                'therapeutic_area',
                'content_type',
                'audience_segment',
                'channel',
                'compliance_level',
                'medical_condition',
                'treatment_type'
            ];
        } catch (error) {
            console.error('Error getting taxonomy categories:', error);
            return ['general'];
        }
    }

    /**
     * Search taxonomy terms
     * @param {string} searchTerm
     * @param {string} [category]
     * @returns {Promise<TaxonomyTerm[]>}
     */
    async searchTaxonomy(searchTerm, category) {
        try {
            const allTerms = this.getMockTaxonomyData(category || 'all');
            return allTerms.filter(term =>
                term.term.toLowerCase().includes(searchTerm.toLowerCase()) ||
                (term.description && term.description.toLowerCase().includes(searchTerm.toLowerCase()))
            );
        } catch (error) {
            console.error('Error searching taxonomy:', error);
            return [];
        }
    }

    /**
     * Get brand-specific taxonomy rules
     * @param {string} brandId
     * @returns {Promise<BrandTaxonomyRule[]>}
     */
    async getBrandTaxonomyRules(brandId) {
        try {
            // Mock data until database types are updated
            /** @type {BrandTaxonomyRule[]} */
            return [
                {
                    id: '1',
                    brand_id: brandId,
                    taxonomy_id: 'oncology-1',
                    is_required: true,
                    is_restricted: false,
                    custom_rules: {}
                }
            ];
        } catch (error) {
            console.error('Error getting brand taxonomy rules:', error);
            return [];
        }
    }

    /**
     * Apply taxonomy to content (prepared for future implementation)
     * @param {string} contentId
     * @param {string} contentType
     * @param {string[]} taxonomyIds
     * @param {boolean} [isAutoGenerated=false]
     * @param {string} [userId]
     * @returns {Promise<TaxonomyMapping[]>}
     */
    async applyTaxonomyToContent(
        contentId,
        contentType,
        taxonomyIds,
        isAutoGenerated = false,
        userId
    ) {
        try {
            // Mock implementation until database is ready
            console.log('Applying taxonomy to content:', { contentId, contentType, taxonomyIds, userId });

            /** @type {TaxonomyMapping[]} */
            return taxonomyIds.map((taxonomyId, index) => ({
                id: `mapping-${index}`,
                content_id: contentId,
                content_type: contentType,
                taxonomy_id: taxonomyId,
                confidence_score: 0.9,
                is_auto_generated: isAutoGenerated
            }));
        } catch (error) {
            console.error('Error applying taxonomy to content:', error);
            return [];
        }
    }

    /**
     * Get content taxonomy mappings
     * @param {string} contentId
     * @param {string} contentType
     * @returns {Promise<TaxonomyMapping[]>}
     */
    async getContentTaxonomy(contentId, contentType) {
        try {
            // Mock implementation until database is ready
            console.log('Getting content taxonomy for:', { contentId, contentType });
            return [];
        } catch (error) {
            console.error('Error getting content taxonomy:', error);
            return [];
        }
    }

    /**
     * Auto-generate taxonomy suggestions for content
     * @param {any} content
     * @param {string} contentType
     * @param {string} brandId
     * @returns {Promise<Array<{ taxonomyId: string; confidence: number; reason: string }>>}
     */
    async generateTaxonomySuggestions(
        content,
        contentType,
        brandId
    ) {
        try {
            /** @type {Array<{ taxonomyId: string; confidence: number; reason: string }>} */
            const suggestions = [];

            // Get mock taxonomy terms
            const taxonomyTerms = this.getMockTaxonomyData('all');

            // Simple keyword-based matching
            const contentText = this.extractTextFromContent(content, contentType);
            const keywords = contentText.toLowerCase().split(/\s+/);

            for (const term of taxonomyTerms) {
                let confidence = 0;
                let reason = '';

                // Exact term match
                if (keywords.some(keyword => keyword.includes(term.term.toLowerCase()))) {
                    confidence += 0.8;
                    reason = `Direct keyword match: "${term.term}"`;
                }

                // Description match
                if (term.description && keywords.some(keyword =>
                    term.description.toLowerCase().includes(keyword))) {
                    confidence += 0.4;
                    reason = reason || `Description match: "${term.description}"`;
                }

                // Content type specific logic (e.g., Project therapeutic area)
                if (contentType === 'project' && content.therapeutic_area) {
                    if (term.category === 'therapeutic_area' &&
                        term.term.toLowerCase().includes(content.therapeutic_area.toLowerCase())) {
                        confidence += 0.9;
                        reason = 'Matches project therapeutic area';
                    }
                }

                if (confidence > 0.5) {
                    suggestions.push({
                        taxonomyId: term.id,
                        confidence: Math.min(confidence, 1.0),
                        reason
                    });
                }
            }

            // Sort by confidence
            return suggestions.sort((a, b) => b.confidence - a.confidence);
        } catch (error) {
            console.error('Error generating taxonomy suggestions:', error);
            return [];
        }
    }

    /**
     * Validate taxonomy compliance for brand
     * @param {string} contentId
     * @param {string} contentType
     * @param {string} brandId
     * @returns {Promise<{isCompliant: boolean, missingRequired: TaxonomyTerm[], restrictedViolations: TaxonomyTerm[], warnings: string[]}>}
     */
    async validateTaxonomyCompliance(
        contentId,
        contentType,
        brandId
    ) {
        try {
            console.log('Validating compliance for:', { contentId, contentType, brandId });
            // Mock implementation until database is ready
            return {
                isCompliant: true,
                missingRequired: [],
                restrictedViolations: [],
                warnings: []
            };
        } catch (error) {
            console.error('Error validating taxonomy compliance:', error);
            throw error;
        }
    }

    /**
     * Get mock taxonomy data for development
     * @private
     * @param {string} category
     * @returns {TaxonomyTerm[]}
     */
    getMockTaxonomyData(category) {
        /** @type {TaxonomyTerm[]} */
        const mockData = [
            {
                id: 'oncology-1',
                category: 'therapeutic_area',
                term: 'Oncology',
                description: 'Cancer treatment and care',
                taxonomy_level: 1,
                is_active: true,
                metadata: {}
            },
            {
                id: 'cardiology-1',
                category: 'therapeutic_area',
                term: 'Cardiology',
                description: 'Heart and cardiovascular care',
                taxonomy_level: 1,
                is_active: true,
                metadata: {}
            },
            {
                id: 'email-1',
                category: 'content_type',
                term: 'Email Campaign',
                description: 'Email marketing content',
                taxonomy_level: 1,
                is_active: true,
                metadata: {}
            },
            {
                id: 'social-1',
                category: 'content_type',
                term: 'Social Media',
                description: 'Social media posts and content',
                taxonomy_level: 1,
                is_active: true,
                metadata: {}
            },
            {
                id: 'hcp-1',
                category: 'audience_segment',
                term: 'Healthcare Professionals',
                description: 'Doctors, nurses, and medical professionals',
                taxonomy_level: 1,
                is_active: true,
                metadata: {}
            },
            {
                id: 'patient-1',
                category: 'audience_segment',
                term: 'Patients',
                description: 'End patients and caregivers',
                taxonomy_level: 1,
                is_active: true,
                metadata: {}
            }
        ];

        if (category === 'all') {
            return mockData;
        }

        return mockData.filter(term => term.category === category);
    }

    /**
     * Extracts relevant text from content object based on its type.
     * @private
     * @param {any} content
     * @param {string} contentType
     * @returns {string}
     */
    extractTextFromContent(content, contentType) {
        let text = '';

        switch (contentType) {
            case 'project':
                text = [
                    content.project_name || '',
                    content.description || '',
                    content.therapeutic_area || '',
                    content.indication || '',
                    JSON.stringify(content.target_audience || {}),
                    JSON.stringify(content.market || []),
                    JSON.stringify(content.channels || [])
                ].join(' ');
                break;

            case 'asset':
                text = [
                    content.asset_name || '',
                    content.target_audience || '',
                    content.content_category || '',
                    content.asset_type || '',
                    JSON.stringify(content.primary_content || {}),
                    JSON.stringify(content.metadata || {})
                ].join(' ');
                break;

            default:
                text = JSON.stringify(content);
        }

        return text;
    }
}

export const taxonomyService = new TaxonomyService();